# v1.3 - Refactoring

I'll review the Bandit CTF Helper Web Application repository and provide a detailed analysis along with suggested improvements. Let me go through the document you've shared.

## Repository Overview

The document contains the development guide for a Bandit CTF Helper Web Application, which is designed to assist users in playing the OverTheWire Bandit Capture The Flag (CTF) challenges. The application has several key components:

1. Terminal Panel for interacting with the Bandit server
2. Chatbox for assistance 
3. Command Reference for tracking used commands
4. Progress Tracking for user advancement
5. Level Detection for automated progress
6. Theming System for visual customization
7. Level Information for structured challenge data

## Analysis of Current Implementation

### Strengths

1. **Well-structured architecture**: The project follows a clear separation of concerns with distinct components for terminal, chat, authentication, and level management.
2. **Comprehensive terminal functionality**: The terminal implementation includes command history, syntax highlighting, and interactive features.
3. **SSH connection management**: The SSH service properly handles connections and command execution.
4. **Level progression system**: The application tracks user progress and detects level completion.
5. **Helpful assistive features**: The chat service and command reference provide contextual help.

### Areas for Improvement

1. **Security considerations**: The current implementation stores passwords in plain text and may have SSH security concerns.
2. **Error handling**: The code could benefit from more robust error handling, especially for network failures.
3. **Test coverage**: There are test directories but no detailed test implementations.
4. **Frontend-backend integration**: The document shows separate implementations but doesn't fully detail how they connect.
5. **Documentation completeness**: The CommandInfoPopup.jsx file is incomplete in the document.

## Suggested Improvements

### 1. Security Enhancements

```python
# Enhanced SSH Service with improved security
import paramiko
import threading
import time
from typing import Dict, Optional, Tuple
import logging
from cryptography.fernet import Fernet
import os

# Setup logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class PasswordManager:
    """Handles secure storage and retrieval of sensitive credentials"""
    
    def __init__(self):
        # Generate or load encryption key
        key_path = os.path.join(os.path.dirname(__file__), '../data/.key')
        if os.path.exists(key_path):
            with open(key_path, 'rb') as f:
                self.key = f.read()
        else:
            self.key = Fernet.generate_key()
            os.makedirs(os.path.dirname(key_path), exist_ok=True)
            with open(key_path, 'wb') as f:
                f.write(self.key)
        
        self.cipher = Fernet(self.key)
    
    def encrypt(self, password: str) -> bytes:
        """Encrypt a password"""
        return self.cipher.encrypt(password.encode())
    
    def decrypt(self, encrypted_password: bytes) -> str:
        """Decrypt an encrypted password"""
        return self.cipher.decrypt(encrypted_password).decode()

class SSHConnection:
    def __init__(self, hostname: str, port: int, username: str, password: str):
        self.hostname = hostname
        self.port = port
        self.username = username
        self.password = password
        self.client = None
        self.channel = None
        self.connected = False
        self.lock = threading.Lock()
        self.last_activity = time.time()
        self.timeout = 300  # 5 minutes inactive timeout
        
    def connect(self) -> bool:
        """Establish SSH connection to the Bandit server with enhanced security checks"""
        try:
            self.client = paramiko.SSHClient()
            
            # Added security: Use system host keys
            self.client.load_system_host_keys()
            self.client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            
            # Connection timeout
            self.client.connect(
                hostname=self.hostname,
                port=self.port,
                username=self.username,
                password=self.password,
                look_for_keys=False,
                allow_agent=False,
                timeout=10
            )
            
            self.channel = self.client.invoke_shell()
            self.channel.settimeout(30)
            self.connected = True
            self.last_activity = time.time()
            
            # Clear initial banner
            time.sleep(1)
            self.channel.recv(4096).decode('utf-8')
            
            # Start idle timeout monitor
            threading.Thread(target=self._monitor_idle_timeout, daemon=True).start()
            
            logger.info(f"Successfully connected to {self.hostname} as {self.username}")
            return True
        except paramiko.AuthenticationException:
            logger.error(f"Authentication failed for {self.username}@{self.hostname}")
            return False
        except paramiko.SSHException as e:
            logger.error(f"SSH error: {str(e)}")
            return False
        except Exception as e:
            logger.error(f"Connection error: {str(e)}")
            return False
    
    def _monitor_idle_timeout(self):
        """Monitor connection for idle timeout"""
        while self.connected:
            time.sleep(60)  # Check every minute
            if time.time() - self.last_activity > self.timeout:
                logger.info(f"Connection {self.username}@{self.hostname} timed out due to inactivity")
                self.disconnect()
                break
    
    def disconnect(self) -> None:
        """Close SSH connection"""
        if self.channel:
            self.channel.close()
        if self.client:
            self.client.close()
        self.connected = False
        logger.info(f"Disconnected from {self.hostname} as {self.username}")
    
    def execute_command(self, command: str) -> str:
        """Execute a command with input sanitization and return the output"""
        with self.lock:
            if not self.connected or not self.channel:
                raise Exception("Not connected to SSH server")
            
            # Updated: Sanitize command input
            sanitized_command = self._sanitize_command(command)
            if sanitized_command != command:
                logger.warning(f"Command was sanitized: {command} -> {sanitized_command}")
                command = sanitized_command
            
            # Update last activity time
            self.last_activity = time.time()
            
            # Send command
            self.channel.send(command + "\n")
            
            # Wait for output
            time.sleep(0.5)
            output = ""
            while self.channel.recv_ready():
                chunk = self.channel.recv(4096).decode('utf-8')
                output += chunk
                if not self.channel.recv_ready():
                    time.sleep(0.1)  # Small delay to ensure all data is received
            
            return output
    
    def _sanitize_command(self, command: str) -> str:
        """Basic command sanitization to prevent command injection"""
        # Block certain dangerous commands
        dangerous_commands = [
            'rm -rf', 'sudo', ':(){:|:&};:', '> /dev/sda', 
            'mkfs', 'dd if=/dev/zero', 'shutdown', 'reboot'
        ]
        
        for dangerous in dangerous_commands:
            if dangerous in command:
                return "echo 'Command blocked for security reasons'"
        
        return command

class SSHManager:
    def __init__(self):
        self.connections: Dict[str, SSHConnection] = {}
        self.password_manager = PasswordManager()
    
    def create_connection(self, session_id: str, level: int, password: str) -> bool:
        """Create a new SSH connection for a specific session and level"""
        hostname = "bandit.labs.overthewire.org"
        port = 2220
        username = f"bandit{level}"
        
        # Store the password securely
        encrypted_password = self.password_manager.encrypt(password)
        
        conn = SSHConnection(hostname, port, username, password)
        success = conn.connect()
        
        if success:
            self.connections[session_id] = conn
            # Security: Log connection success without password
            logger.info(f"Created connection for session {session_id} to level {level}")
        else:
            # Security: Log failed connection without password
            logger.warning(f"Failed to create connection for session {session_id} to level {level}")
        
        return success
    
    def close_connection(self, session_id: str) -> None:
        """Close an existing SSH connection"""
        if session_id in self.connections:
            self.connections[session_id].disconnect()
            del self.connections[session_id]
            logger.info(f"Closed connection for session {session_id}")
    
    def execute_command(self, session_id: str, command: str) -> Tuple[str, bool]:
        """Execute a command on a specific session and check for level completion"""
        if session_id not in self.connections:
            return "Not connected to the server. Please reconnect.", False
        
        try:
            output = self.connections[session_id].execute_command(command)
            
            # Check if this command revealed a password (level completion)
            level_completed = self.check_for_password(output)
            
            return output, level_completed
        except Exception as e:
            logger.error(f"Error executing command in session {session_id}: {str(e)}")
            return f"Error executing command: {str(e)}", False
    
    def check_for_password(self, output: str) -> bool:
        """Check if output contains a potential password for the next level"""
        import re
        # Looking for strings that look like passwords (alphanumeric, 10-32 chars)
        password_pattern = r'\b[a-zA-Z0-9]{10,32}\b'
        potential_passwords = re.findall(password_pattern, output)
        
        return len(potential_passwords) > 0
    
    def cleanup_idle_connections(self) -> None:
        """Clean up idle connections that haven't been properly closed"""
        for session_id, connection in list(self.connections.items()):
            if time.time() - connection.last_activity > connection.timeout:
                logger.info(f"Cleaning up idle connection for session {session_id}")
                self.close_connection(session_id)

# Singleton instance
ssh_manager = SSHManager()

# Schedule periodic cleanup
def start_cleanup_scheduler():
    def cleanup_task():
        while True:
            time.sleep(300)  # Run every 5 minutes
            ssh_manager.cleanup_idle_connections()
    
    cleanup_thread = threading.Thread(target=cleanup_task, daemon=True)
    cleanup_thread.start()

# Start the cleanup scheduler
start_cleanup_scheduler()

```

### 2. Enhanced Error Handling and Logging

```python
# app/utils/error_handler.py
import logging
import traceback
import functools
import json
from flask import jsonify, current_app, request
from typing import Callable, Any, Dict, Optional

# Configure logger
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("app.log"),
        logging.StreamHandler()
    ]
)

logger = logging.getLogger("bandit_ctf_helper")

# Error codes
class ErrorCodes:
    AUTH_ERROR = 1001
    SSH_CONNECTION_ERROR = 2001
    COMMAND_EXECUTION_ERROR = 2002
    DATABASE_ERROR = 3001
    LEVEL_DATA_ERROR = 4001
    VALIDATION_ERROR = 5001
    SERVER_ERROR = 9001

class APIError(Exception):
    """Base class for API errors"""
    def __init__(
        self, 
        message: str, 
        code: int, 
        status_code: int = 400, 
        details: Optional[Dict] = None
    ):
        self.message = message
        self.code = code
        self.status_code = status_code
        self.details = details
        super().__init__(self.message)

    def to_dict(self) -> Dict:
        """Convert error to dictionary for JSON response"""
        error_dict = {
            "error": True,
            "code": self.code,
            "message": self.message
        }
        if self.details:
            error_dict["details"] = self.details
        return error_dict

def api_error_handler(f: Callable) -> Callable:
    """Decorator to handle API errors and return proper JSON responses"""
    @functools.wraps(f)
    def decorated(*args, **kwargs) -> Any:
        try:
            return f(*args, **kwargs)
        except APIError as e:
            # Log the error
            logger.error(f"API Error: {e.message} (Code: {e.code})")
            if e.details:
                logger.error(f"Error details: {json.dumps(e.details)}")
            
            # Return JSON error response
            response = jsonify(e.to_dict())
            response.status_code = e.status_code
            return response
        except Exception as e:
            # Log unexpected errors
            error_details = {
                "exception": str(e),
                "traceback": traceback.format_exc(),
                "endpoint": request.path,
                "method": request.method,
            }
            
            logger.error(f"Unexpected error: {str(e)}")
            logger.error(f"Error details: {json.dumps(error_details)}")
            
            # Return generic error for production
            if current_app.config.get("DEBUG", False):
                # In debug mode, return detailed error
                response = jsonify({
                    "error": True,
                    "code": ErrorCodes.SERVER_ERROR,
                    "message": str(e),
                    "traceback": traceback.format_exc()
                })
            else:
                # In production, return generic error
                response = jsonify({
                    "error": True,
                    "code": ErrorCodes.SERVER_ERROR,
                    "message": "An unexpected error occurred"
                })
            
            response.status_code = 500
            return response
    
    return decorated

# Example usage in routes
# app/routes/terminal.py
from flask import Blueprint, request, jsonify
from app.services.terminal_service import terminal_service
from app.utils.error_handler import api_error_handler, APIError, ErrorCodes

bp = Blueprint('terminal', __name__)

@bp.route('/execute', methods=['POST'])
@api_error_handler
def execute_command():
    data = request.json
    
    # Validate request data
    if not data or 'command' not in data or 'session_id' not in data:
        raise APIError(
            message="Invalid request: missing required fields",
            code=ErrorCodes.VALIDATION_ERROR,
            details={"required": ["command", "session_id"]}
        )
    
    try:
        output, level_completed = terminal_service.execute_command(
            data.get('user_id'), 
            data.get('session_id'), 
            data.get('command')
        )
        
        return jsonify({
            "output": output,
            "levelCompleted": level_completed
        })
    except Exception as e:
        raise APIError(
            message=f"Command execution failed: {str(e)}",
            code=ErrorCodes.COMMAND_EXECUTION_ERROR,
            status_code=500
        )

```

### 3. Frontend Component Improvements

```jsx
// Terminal.jsx with accessibility improvements
import React, { useState, useEffect, useRef } from 'react';
import { useTerminalContext } from '../contexts/TerminalContext';
import CommandInput from './CommandInput';
import CommandOutput from './CommandOutput';
import CommandInfoPopup from './CommandInfoPopup';
import useKeyboardShortcuts from '../hooks/useKeyboardShortcuts';
import { toast } from 'react-toastify';
import './Terminal.css';

const Terminal = () => {
  const terminalRef = useRef(null);
  const inputRef = useRef(null);
  const [showPopup, setShowPopup] = useState(false);
  const [popupCommand, setPopupCommand] = useState(null);
  const [loading, setLoading] = useState(false);
  
  const { 
    connected,
    connecting,
    output, 
    sendCommand,
    connect,
    disconnect,
    levelCompleted,
    commandHistory,
    currentLevel,
    error
  } = useTerminalContext();
  
  // Register keyboard shortcuts
  useKeyboardShortcuts({
    'Ctrl+L': () => sendCommand('clear'),
    'Ctrl+C': () => sendCommand('^C'),
    'Alt+T': () => inputRef.current?.focus(),
    'Escape': () => setShowPopup(false)
  });
  
  // Auto-scroll to bottom when new output is received
  useEffect(() => {
    if (terminalRef.current) {
      terminalRef.current.scrollTop = terminalRef.current.scrollHeight;
    }
  }, [output]);
  
  // Show error toast when error occurs
  useEffect(() => {
    if (error) {
      toast.error(error, {
        position: "top-right",
        autoClose: 5000,
        hideProgressBar: false,
        closeOnClick: true,
        pauseOnHover: true,
        draggable: true
      });
    }
  }, [error]);
  
  // Show command info popup when a command is clicked
  const handleCommandClick = (command) => {
    setPopupCommand(command);
    setShowPopup(true);
  };
  
  // Handle connection with loading state
  const handleConnect = async () => {
    setLoading(true);
    try {
      await connect();
    } catch (err) {
      console.error("Connection error:", err);
    } finally {
      setLoading(false);
    }
  };
  
  return (
    <div 
      className="terminal-panel" 
      role="region" 
      aria-label="SSH Terminal"
    >
      <div className="terminal-header">
        <div className="terminal-title">
          <h2>Bandit Level {currentLevel}</h2>
          <div className="connection-status">
            Status: <span className={connected ? "connected" : "disconnected"}>
              {connected ? "Connected" : "Disconnected"}
            </span>
          </div>
        </div>
        <div className="terminal-controls">
          {!connected ? (
            <button 
              className="connect-button" 
              onClick={handleConnect}
              disabled={connecting || loading}
              aria-busy={connecting || loading}
            >
              {connecting || loading ? 'Connecting...' : 'Connect'}
            </button>
          ) : (
            <button 
              className="disconnect-button" 
              onClick={disconnect}
              aria-label="Disconnect from SSH server"
            >
              Disconnect
            </button>
          )}
          <button 
            className="help-button"
            onClick={() => setShowPopup(true)}
            aria-label="Show keyboard shortcuts"
          >
            <span aria-hidden="true">?</span>
          </button>
        </div>
      </div>
      
      <div 
        className="terminal-body" 
        ref={terminalRef}
        tabIndex={0}
        role="log"
        aria-live="polite"
        aria-label="Terminal output"
      >
        <CommandOutput 
          output={output} 
          onCommandClick={handleCommandClick}
        />
      </div>
      
      <CommandInput 
        ref={inputRef}
        onSendCommand={sendCommand}
        disabled={!connected}
        history={commandHistory}
        ariaLabel="Terminal command input"
      />
      
      {showPopup && (
        <CommandInfoPopup
          command={popupCommand || 'help'}
          onClose={() => setShowPopup(false)}
        />
      )}
      
      {levelCompleted && (
        <div 
          className="level-completed-notification"
          role="alertdialog"
          aria-labelledby="level-completed-title"
        >
          <div className="notification-content">
            <h3 id="level-completed-title">Level Completed!</h3>
            <p>You've found the password for the next level!</p>
            <div className="notification-actions">
              <button 
                onClick={() => window.location.reload()}
                className="primary-button"
              >
                Continue to Next Level
              </button>
              <button 
                onClick={() => document.getElementById('chatbox-input').focus()}
                className="secondary-button"
              >
                Get Help for Next Level
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default Terminal;

// useKeyboardShortcuts.js - Custom hook for keyboard shortcuts
import { useEffect } from 'react';

const useKeyboardShortcuts = (shortcuts) => {
  useEffect(() => {
    const handleKeyDown = (event) => {
      // Build key combination string (e.g., "Ctrl+L")
      let combo = '';
      if (event.ctrlKey) combo += 'Ctrl+';
      if (event.altKey) combo += 'Alt+';
      if (event.shiftKey) combo += 'Shift+';
      
      // Add the actual key
      combo += event.key.toUpperCase();
      
      // Execute shortcut function if it exists
      if (shortcuts[combo]) {
        event.preventDefault();
        shortcuts[combo]();
      }
    };
    
    // Add event listener
    window.addEventListener('keydown', handleKeyDown);
    
    // Clean up
    return () => {
      window.addEventListener('keydown', handleKeyDown);
    };
  }, [shortcuts]);
};

export default useKeyboardShortcuts;

// CommandInput.jsx with accessibility improvements
import React, { useState, useRef, useEffect, forwardRef } from 'react';

const CommandInput = forwardRef(({ onSendCommand, disabled, history, ariaLabel }, ref) => {
  const [command, setCommand] = useState('');
  const [historyIndex, setHistoryIndex] = useState(-1);
  const inputRef = useRef(null);
  
  // Expose inputRef through forwardRef
  useEffect(() => {
    if (ref) {
      if (typeof ref === 'function') {
        ref(inputRef.current);
      } else {
        ref.current = inputRef.current;
      }
    }
  }, [ref]);
  
  // Focus input when component mounts
  useEffect(() => {
    if (inputRef.current && !disabled) {
      inputRef.current.focus();
    }
  }, [disabled]);
  
  // Handle key press events
  const handleKeyDown = (e) => {
    // Arrow up to navigate history
    if (e.key === 'ArrowUp' && historyIndex < history.length - 1) {
      e.preventDefault();
      const newIndex = historyIndex + 1;
      setHistoryIndex(newIndex);
      setCommand(history[history.length - 1 - newIndex]);
    }
    // Arrow down to navigate history
    else if (e.key === 'ArrowDown' && historyIndex > -1) {
      e.preventDefault();
      const newIndex = historyIndex - 1;
      setHistoryIndex(newIndex);
      setCommand(newIndex >= 0 ? history[history.length - 1 - newIndex] : '');
    }
    // Tab for command completion (basic implementation)
    else if (e.key === 'Tab') {
      e.preventDefault();
      // Simple command completion example - add more sophisticated logic as needed
      const commonCommands = ['ls', 'cat', 'cd', 'find', 'grep', 'pwd', 'whoami', 'file'];
      
      for (const cmd of commonCommands) {
        if (cmd.startsWith(command) && cmd !== command) {
          setCommand(cmd);
          break;
        }
      }
    }
    // Enter to submit command
    else if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSubmit();
    }
  };
  
  // Handle command submission
  const handleSubmit = () => {
    if (command.trim() && !disabled) {
      onSendCommand(command);
      setCommand('');
      setHistoryIndex(-1);
      
      // Refocus input after submission
      setTimeout(() => {
        if (inputRef.current) {
          inputRef.current.focus();
        }
      }, 0);
    }
  };
  
  return (
    <div className="command-input-container" role="form">
      <div className="command-prompt" aria-hidden="true">bandit$</div>
      <input
        ref={inputRef}
        type="text"
        className="command-input"
        value={command}
        onChange={(e) => setCommand(e.target.value)}
        onKeyDown={handleKeyDown}
        disabled={disabled}
        placeholder={disabled ? "Connect to start..." : "Enter command..."}
        aria-label={ariaLabel || "Terminal command input"}
        autoComplete="off"
        spellCheck="false"
      />
      <button
        className="send-button"
        onClick={handleSubmit}
        disabled={disabled || !command.trim()}
        aria-label="Execute command"
      >
        <span aria-hidden="true">Send</span>
      </button>
    </div>
  );
});

export default CommandInput;

```

### 4. Testing Framework

```python
# tests/test_ssh_service.py
import unittest
from unittest.mock import patch, MagicMock
import paramiko
from app.services.ssh_service import SSHConnection, SSHManager

class TestSSHConnection(unittest.TestCase):
    @patch('paramiko.SSHClient')
    def test_connect_success(self, mock_ssh_client):
        # Setup mocks
        mock_client = MagicMock()
        mock_channel = MagicMock()
        mock_ssh_client.return_value = mock_client
        mock_client.invoke_shell.return_value = mock_channel
        
        # Create connection
        connection = SSHConnection('hostname', 22, 'username', 'password')
        
        # Test connection
        result = connection.connect()
        
        # Assertions
        self.assertTrue(result)
        self.assertTrue(connection.connected)
        mock_client.set_missing_host_key_policy.assert_called_once()
        mock_client.connect.assert_called_once_with(
            hostname='hostname',
            port=22,
            username='username',
            password='password',
            look_for_keys=False,
            allow_agent=False,
            timeout=10
        )
    
    @patch('paramiko.SSHClient')
    def test_connect_failure_auth(self, mock_ssh_client):
        # Setup mocks
        mock_client = MagicMock()
        mock_ssh_client.return_value = mock_client
        mock_client.connect.side_effect = paramiko.AuthenticationException("Auth failed")
        
        # Create connection
        connection = SSHConnection('hostname', 22, 'username', 'wrong_password')
        
        # Test connection
        result = connection.connect()
        
        # Assertions
        self.assertFalse(result)
        self.assertFalse(connection.connected)
    
    @patch('paramiko.SSHClient')
    def test_disconnect(self, mock_ssh_client):
        # Setup mocks
        mock_client = MagicMock()
        mock_channel = MagicMock()
        mock_ssh_client.return_value = mock_client
        mock_client.invoke_shell.return_value = mock_channel
        
        # Create and connect
        connection = SSHConnection('hostname', 22, 'username', 'password')
        connection.connect()
        
        # Test disconnect
        connection.disconnect()
        
        # Assertions
        self.assertFalse(connection.connected)
        mock_channel.close.assert_called_once()
        mock_client.close.assert_called_once()
    
    @patch('paramiko.SSHClient')
    def test_execute_command(self, mock_ssh_client):
        # Setup mocks
        mock_client = MagicMock()
        mock_channel = MagicMock()
        mock_ssh_client.return_value = mock_client
        mock_client.invoke_shell.return_value = mock_channel
        
        # Setup channel to return output
        mock_channel.recv_ready.side_effect = [True, True, False]
        mock_channel.recv.return_value = "Command output".encode()
        
        # Create and connect
        connection = SSHConnection('hostname', 22, 'username', 'password')
        connection.connect()
        
        # Test execute command
        output = connection.execute_command("test command")
        
        # Assertions
        self.assertEqual(output, "Command output" * 2)  # Twice because recv_ready returns True twice
        mock_channel.send.assert_called_once_with("test command\n")
    
    @patch('paramiko.SSHClient')
    def test_command_sanitization(self, mock_ssh_client):
        # Setup mocks
        mock_client = MagicMock()
        mock_channel = MagicMock()
        mock_ssh_client.return_value = mock_client
        mock_client.invoke_shell.return_value = mock_channel
        
        # Create and connect
        connection = SSHConnection('hostname', 22, 'username', 'password')
        connection.connect()
        
        # Test dangerous command
        connection.execute_command("rm -rf /")
        
        # Assert sanitized command was sent
        mock_channel.send.assert_called_once_with("echo 'Command blocked for security reasons'\n")

# tests/test_terminal_service.py
import unittest
from unittest.mock import patch, MagicMock
from app.services.terminal_service import TerminalService

class TestTerminalService(unittest.TestCase):
    @patch('app.services.ssh_service.ssh_manager')
    @patch('app.models.command_history.CommandHistory')
    @patch('app.models.progress.Progress')
    def test_execute_command(self, mock_progress, mock_command_history, mock_ssh_manager):
        # Setup mocks
        mock_ssh_manager.execute_command.return_value = ("Command output", False)
        
        # Create service
        service = TerminalService()
        
        # Test execute command
        output, level_completed = service.execute_command("user1", "session1", "ls")
        
        # Assertions
        self.assertEqual(output, "Command output")
        self.assertFalse(level_completed)
        mock_command_history.add_command.assert_called_once_with("user1", "ls")
        mock_ssh_manager.execute_command.assert_called_once_with("session1", "ls")
    
    @patch('app.services.ssh_service.ssh_manager')
    @patch('app.models.command_history.CommandHistory')
    @patch('app.models.progress.Progress')
    def test_execute_command_level_completed(self, mock_progress, mock_command_history, mock_ssh_manager):
        # Setup mocks
        mock_ssh_manager.execute_command.return_value = ("Output with password: abc123xyz789", True)
        mock_progress.get_current_level.return_value = 0
        
        
```