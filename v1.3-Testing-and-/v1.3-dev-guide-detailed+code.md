# Bandit CTF Helper Web Application - Development Guide

## Table of Contents
1. [Overview](#overview)
2. [Architecture](#architecture)
3. [Backend Implementation](#backend-implementation)
4. [Frontend Implementation](#frontend-implementation)
5. [Authentication & Progress Tracking](#authentication-progress-tracking)
6. [Level Management](#level-management)
7. [Terminal Implementation](#terminal-implementation)
8. [Chatbox Implementation](#chatbox-implementation)
9. [Command Reference System](#command-reference-system)
10. [Theme Management](#theme-management)
11. [Deployment Instructions](#deployment-instructions)

## Overview

The Bandit CTF Helper is a web application designed to assist users in playing the OverTheWire Bandit Capture The Flag (CTF) challenges. The application provides a terminal interface for interacting with the Bandit game server, a chatbox for assistance, a command reference for frequently used commands, and tracks user progress through the challenges.

### Key Features

- **Terminal Panel**: Interactive terminal for sending commands to the Bandit server and displaying output
- **Chatbox**: AI-assisted help system for command suggestions, objectives, and learning resources
- **Command Reference**: Auto-populated cheat sheet of previously used commands
- **Progress Tracking**: Save and load user progress through the challenges
- **Level Detection**: Automatically detect when a level is completed
- **Theming System**: Multiple theme options (Light, Dark, Tokyo Night, Dracula, GitHub)
- **Level Information**: Structured data for each level's objectives, hints, and resources

## Architecture

### Technology Stack

- **Backend**: Python with Flask
- **Frontend**: HTML, CSS, JavaScript (React)
- **SSH Interaction**: Paramiko library
- **Database**: SQLite (development) / PostgreSQL (production)
- **Authentication**: JWT-based authentication
- **WebSockets**: For real-time terminal updates

### System Components

1. **Web Server**: Handles HTTP requests, serves frontend, manages WebSocket connections
2. **SSH Manager**: Manages SSH connections to the Bandit server using Paramiko
3. **Terminal Service**: Handles terminal input/output and session management
4. **Chat Service**: Processes chat queries and provides contextual assistance
5. **User Service**: Handles user authentication and progress tracking
6. **Level Manager**: Loads and provides level information and objectives

## Backend Implementation

### Directory Structure

```
bandit-ctf-helper/
├── app/
│   ├── __init__.py
│   ├── config.py
│   ├── main.py
│   ├── models/
│   │   ├── __init__.py
│   │   ├── user.py
│   │   ├── progress.py
│   │   └── command_history.py
│   ├── services/
│   │   ├── __init__.py
│   │   ├── ssh_service.py
│   │   ├── terminal_service.py
│   │   ├── chat_service.py
│   │   └── level_service.py
│   ├── routes/
│   │   ├── __init__.py
│   │   ├── auth.py
│   │   ├── terminal.py
│   │   ├── chat.py
│   │   └── progress.py
│   ├── levels/
│   │   ├── level0.json
│   │   ├── level1.json
│   │   └── ...
│   └── utils/
│       ├── __init__.py
│       ├── auth.py
│       ├── terminal_parser.py
│       └── command_analyzer.py
├── tests/
│   ├── __init__.py
│   ├── test_ssh_service.py
│   ├── test_terminal_service.py
│   └── ...
├── .env
├── requirements.txt
└── run.py
```

### Core Backend Components

#### Flask Application Setup (app/__init__.py)

```python
from flask import Flask
from flask_sqlalchemy import SQLAlchemy
from flask_jwt_extended import JWTManager
from flask_socketio import SocketIO
from flask_cors import CORS
from .config import Config

db = SQLAlchemy()
jwt = JWTManager()
socketio = SocketIO()

def create_app(config_class=Config):
    app = Flask(__name__)
    app.config.from_object(config_class)
    
    # Initialize extensions
    db.init_app(app)
    jwt.init_app(app)
    CORS(app)
    socketio.init_app(app, cors_allowed_origins="*")
    
    # Register blueprints
    from app.routes.auth import bp as auth_bp
    from app.routes.terminal import bp as terminal_bp
    from app.routes.chat import bp as chat_bp
    from app.routes.progress import bp as progress_bp
    
    app.register_blueprint(auth_bp, url_prefix='/api/auth')
    app.register_blueprint(terminal_bp, url_prefix='/api/terminal')
    app.register_blueprint(chat_bp, url_prefix='/api/chat')
    app.register_blueprint(progress_bp, url_prefix='/api/progress')
    
    # Create database tables
    with app.app_context():
        db.create_all()
    
    return app
```

#### SSH Service (app/services/ssh_service.py)

```python
import paramiko
import threading
import time
from typing import Dict, Optional, Tuple

class SSHConnection:
    def __init__(self, hostname: str, port: int, username: str, password: str):
        self.hostname = hostname
        self.port = port
        self.username = username
        self.password = password
        self.client = None
        self.channel = None
        self.connected = False
        self.lock = threading.Lock()
        
    def connect(self) -> bool:
        """Establish SSH connection to the Bandit server"""
        try:
            self.client = paramiko.SSHClient()
            self.client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            self.client.connect(
                hostname=self.hostname,
                port=self.port,
                username=self.username,
                password=self.password,
                look_for_keys=False,
                allow_agent=False
            )
            
            self.channel = self.client.invoke_shell()
            self.channel.settimeout(30)
            self.connected = True
            
            # Clear initial banner
            time.sleep(1)
            self.channel.recv(4096).decode('utf-8')
            
            return True
        except Exception as e:
            print(f"SSH connection error: {str(e)}")
            return False
    
    def disconnect(self) -> None:
        """Close SSH connection"""
        if self.channel:
            self.channel.close()
        if self.client:
            self.client.close()
        self.connected = False
    
    def execute_command(self, command: str) -> str:
        """Execute a command and return the output"""
        with self.lock:
            if not self.connected or not self.channel:
                raise Exception("Not connected to SSH server")
            
            # Send command
            self.channel.send(command + "\n")
            
            # Wait for output
            time.sleep(0.5)
            output = ""
            while self.channel.recv_ready():
                chunk = self.channel.recv(4096).decode('utf-8')
                output += chunk
                if not self.channel.recv_ready():
                    time.sleep(0.1)  # Small delay to ensure all data is received
            
            return output

class SSHManager:
    def __init__(self):
        self.connections: Dict[str, SSHConnection] = {}
    
    def create_connection(self, session_id: str, level: int, password: str) -> bool:
        """Create a new SSH connection for a specific session and level"""
        hostname = "bandit.labs.overthewire.org"
        port = 2220
        username = f"bandit{level}"
        
        conn = SSHConnection(hostname, port, username, password)
        success = conn.connect()
        
        if success:
            self.connections[session_id] = conn
        
        return success
    
    def close_connection(self, session_id: str) -> None:
        """Close an existing SSH connection"""
        if session_id in self.connections:
            self.connections[session_id].disconnect()
            del self.connections[session_id]
    
    def execute_command(self, session_id: str, command: str) -> Tuple[str, bool]:
        """Execute a command on a specific session and check for level completion"""
        if session_id not in self.connections:
            return "Not connected to the server. Please reconnect.", False
        
        try:
            output = self.connections[session_id].execute_command(command)
            
            # Check if this command revealed a password (level completion)
            level_completed = self.check_for_password(output)
            
            return output, level_completed
        except Exception as e:
            return f"Error executing command: {str(e)}", False
    
    def check_for_password(self, output: str) -> bool:
        """Check if output contains a potential password for the next level"""
        # Simple heuristic: Look for strings that match Bandit password format
        # In real implementation, we would have more sophisticated detection
        import re
        # Looking for strings that look like passwords (alphanumeric, 10-32 chars)
        password_pattern = r'\b[a-zA-Z0-9]{10,32}\b'
        potential_passwords = re.findall(password_pattern, output)
        
        return len(potential_passwords) > 0

# Singleton instance
ssh_manager = SSHManager()
```

#### Terminal Service (app/services/terminal_service.py)

```python
from typing import Dict, List, Optional, Tuple
from app.services.ssh_service import ssh_manager
from app.models.command_history import CommandHistory
from app.models.progress import Progress

class TerminalService:
    def __init__(self):
        self.command_history: Dict[str, List[str]] = {}
    
    def execute_command(self, user_id: str, session_id: str, command: str) -> Tuple[str, bool]:
        """Execute a command and process the output"""
        # Store command in history
        if user_id not in self.command_history:
            self.command_history[user_id] = []
        
        # Don't store password commands in history
        if not self._is_password_command(command):
            self.command_history[user_id].append(command)
            # Save to database for persistence
            CommandHistory.add_command(user_id, command)
        
        # Execute command via SSH manager
        output, level_completed = ssh_manager.execute_command(session_id, command)
        
        # Process output for syntax highlighting
        processed_output = self._process_output(command, output)
        
        # If level completed, update user progress
        if level_completed:
            # Extract potential password and update progress
            next_level_password = self._extract_password(output)
            if next_level_password:
                current_level = Progress.get_current_level(user_id)
                Progress.update_level(user_id, current_level + 1, next_level_password)
        
        return processed_output, level_completed
    
    def _is_password_command(self, command: str) -> bool:
        """Check if command contains a password (to avoid storing in history)"""
        return any(pwd_cmd in command.lower() for pwd_cmd in ['password', 'cat /etc/bandit_pass', 'ssh'])
    
    def _process_output(self, command: str, output: str) -> str:
        """Process terminal output for syntax highlighting"""
        # Add syntax highlighting classes
        # This is a simplified example - actual implementation would be more complex
        processed = output
        
        # Add highlighting for errors
        if "error" in output.lower() or "permission denied" in output.lower():
            processed = f'<span class="terminal-error">{output}</span>'
        
        # Add highlighting for successful commands
        elif command.startswith(('ls', 'find', 'grep')):
            lines = output.split('\n')
            highlighted_lines = []
            
            for line in lines:
                # Highlight files differently from directories
                if line.endswith('/'):
                    highlighted_lines.append(f'<span class="terminal-directory">{line}</span>')
                elif '.' in line:
                    highlighted_lines.append(f'<span class="terminal-file">{line}</span>')
                else:
                    highlighted_lines.append(line)
            
            processed = '\n'.join(highlighted_lines)
        
        return processed
    
    def _extract_password(self, output: str) -> Optional[str]:
        """Extract potential password from output"""
        import re
        password_pattern = r'\b[a-zA-Z0-9]{10,32}\b'
        potential_passwords = re.findall(password_pattern, output)
        
        if potential_passwords:
            return potential_passwords[0]
        return None
    
    def get_command_history(self, user_id: str) -> List[str]:
        """Get command history for a user"""
        # Return from memory if available, otherwise load from database
        if user_id in self.command_history:
            return self.command_history[user_id]
        else:
            commands = CommandHistory.get_commands(user_id)
            self.command_history[user_id] = commands
            return commands

# Singleton instance
terminal_service = TerminalService()
```

#### Chat Service (app/services/chat_service.py)

```python
from typing import Dict, List, Optional
import json
import os
import re
from app.services.level_service import level_service

class ChatService:
    def __init__(self):
        self.faq = self._load_faq()
    
    def _load_faq(self) -> Dict[str, List[Dict]]:
        """Load frequently asked questions and answers"""
        faq_path = os.path.join(os.path.dirname(__file__), '../data/faq.json')
        with open(faq_path, 'r') as f:
            return json.load(f)
    
    def process_message(self, message: str, level: int) -> str:
        """Process a user message and provide a helpful response"""
        # Convert to lowercase for keyword matching
        message_lower = message.lower()
        
        # Check for keywords
        if 'help' in message_lower:
            return self._provide_help(message_lower, level)
        elif 'commands' in message_lower:
            return self._suggest_commands(level)
        elif 'hint' in message_lower:
            return self._provide_hint(level)
        elif 'objective' in message_lower:
            return self._provide_objective(level)
        else:
            # Search FAQ for relevant answers
            for entry in self.faq.get('general', []):
                if any(keyword in message_lower for keyword in entry.get('keywords', [])):
                    return entry.get('answer', '')
            
            # If no match, provide a generic response
            return (
                "I can help you with the following topics:\n\n"
                "- Type **help** for learning resources\n"
                "- Type **commands** for command suggestions\n"
                "- Type **hint** for level hints\n"
                "- Type **objective** to see the current level's objective\n\n"
                "Or ask me any specific question about Linux commands or the Bandit challenges!"
            )
    
    def _provide_help(self, message: str, level: int) -> str:
        """Provide help and learning resources"""
        # Check for specific command help
        command_match = re.search(r'help\s+with\s+([a-z0-9_-]+)', message)
        if command_match:
            command = command_match.group(1)
            return self._provide_command_help(command)
        
        # Otherwise return general learning resources for this level
        resources = level_service.get_level_resources(level)
        
        response = "## Learning Resources\n\n"
        for resource in resources:
            response += f"- [{resource['title']}]({resource['url']}): {resource['description']}\n"
        
        return response
    
    def _provide_command_help(self, command: str) -> str:
        """Provide help for a specific command"""
        # Look up command in our command database
        command_help = self.faq.get('commands', {}).get(command)
        
        if command_help:
            response = f"## {command} Command\n\n"
            response += f"**Description:** {command_help['description']}\n\n"
            response += "**Syntax:**\n```bash\n{}\n```\n\n".format(command_help['syntax'])
            
            if 'examples' in command_help:
                response += "**Examples:**\n"
                for example in command_help['examples']:
                    response += f"- `{example['command']}`: {example['explanation']}\n"
            
            if 'options' in command_help:
                response += "\n**Common Options:**\n"
                for option in command_help['options']:
                    response += f"- `{option['flag']}`: {option['description']}\n"
            
            return response
        else:
            return f"I don't have specific information about the `{command}` command. You can try running `man {command}` in the terminal to see its manual page."
    
    def _suggest_commands(self, level: int) -> str:
        """Suggest useful commands for the current level"""
        commands = level_service.get_level_commands(level)
        
        response = f"## Useful Commands for Level {level}\n\n"
        for cmd in commands:
            response += f"- `{cmd['command']}`: {cmd['description']}\n"
        
        return response
    
    def _provide_hint(self, level: int) -> str:
        """Provide a hint for the current level"""
        hints = level_service.get_level_hints(level)
        
        if not hints:
            return f"Sorry, I don't have any hints for level {level} yet."
        
        # Return a random hint
        import random
        hint = random.choice(hints)
        
        return f"## Hint for Level {level}\n\n{hint}"
    
    def _provide_objective(self, level: int) -> str:
        """Provide the objective for the current level"""
        objective = level_service.get_level_objective(level)
        
        response = f"## Level {level} Objective\n\n{objective['description']}\n\n"
        
        if 'goals' in objective:
            response += "**Goals:**\n"
            for goal in objective['goals']:
                response += f"- {goal}\n"
        
        return response

# Singleton instance
chat_service = ChatService()
```

#### Level Service (app/services/level_service.py)

```python
import json
import os
from typing import Dict, List, Any, Optional

class LevelService:
    def __init__(self):
        self.levels = {}
        self._load_levels()
    
    def _load_levels(self) -> None:
        """Load all level data from JSON files"""
        levels_dir = os.path.join(os.path.dirname(__file__), '../levels')
        
        for filename in os.listdir(levels_dir):
            if filename.endswith('.json'):
                level_num = int(filename.split('.')[0].replace('level', ''))
                
                with open(os.path.join(levels_dir, filename), 'r') as f:
                    level_data = json.load(f)
                    self.levels[level_num] = level_data
    
    def get_level_data(self, level: int) -> Dict[str, Any]:
        """Get all data for a specific level"""
        if level in self.levels:
            return self.levels[level]
        else:
            return {"error": f"Level {level} not found"}
    
    def get_level_objective(self, level: int) -> Dict[str, Any]:
        """Get the objective for a specific level"""
        level_data = self.get_level_data(level)
        return level_data.get('objective', {"description": "No objective available"})
    
    def get_level_hints(self, level: int) -> List[str]:
        """Get hints for a specific level"""
        level_data = self.get_level_data(level)
        return level_data.get('hints', [])
    
    def get_level_commands(self, level: int) -> List[Dict[str, str]]:
        """Get useful commands for a specific level"""
        level_data = self.get_level_data(level)
        return level_data.get('commands', [])
    
    def get_level_resources(self, level: int) -> List[Dict[str, str]]:
        """Get learning resources for a specific level"""
        level_data = self.get_level_data(level)
        return level_data.get('resources', [])
    
    def get_level_password_pattern(self, level: int) -> Optional[str]:
        """Get the password pattern for a specific level (for validation)"""
        level_data = self.get_level_data(level)
        return level_data.get('password_pattern')

# Singleton instance
level_service = LevelService()
```

### Sample Level JSON Structure

```json
{
  "objective": {
    "description": "The password for the next level is stored in a file called readme in the home directory.",
    "goals": [
      "Find and read the 'readme' file to get the password for level 1"
    ]
  },
  "hints": [
    "You can use the 'ls' command to list files in the current directory",
    "Use 'cat' command to read the contents of a file",
    "Remember that Linux is case-sensitive, so 'README' and 'readme' are different files"
  ],
  "commands": [
    {
      "command": "ls",
      "description": "List directory contents"
    },
    {
      "command": "cat readme",
      "description": "Display the contents of the readme file"
    },
    {
      "command": "pwd",
      "description": "Print working directory"
    }
  ],
  "resources": [
    {
      "title": "Basic Linux Commands",
      "url": "https://linuxcommand.org/lc3_lts0060.php",
      "description": "An introduction to basic Linux commands for beginners"
    },
    {
      "title": "File Operations in Linux",
      "url": "https://www.digitalocean.com/community/tutorials/basic-linux-navigation-and-file-management",
      "description": "Learn how to navigate and manage files in Linux"
    }
  ],
  "password_pattern": "^[a-zA-Z0-9]{10,32}$"
}
```

## Frontend Implementation

### Terminal Component

The terminal component is the core of the application, allowing users to interact with the Bandit server through an SSH connection.

#### Terminal.jsx

```jsx
import React, { useState, useEffect, useRef } from 'react';
import { useTerminalContext } from '../contexts/TerminalContext';
import CommandInput from './CommandInput';
import CommandOutput from './CommandOutput';
import CommandInfoPopup from './CommandInfoPopup';
import './Terminal.css';

const Terminal = () => {
  const terminalRef = useRef(null);
  const [showPopup, setShowPopup] = useState(false);
  const [popupCommand, setPopupCommand] = useState(null);
  
  const { 
    connected,
    connecting,
    output, 
    sendCommand,
    connect,
    disconnect,
    levelCompleted,
    commandHistory,
    currentLevel
  } = useTerminalContext();
  
  // Auto-scroll to bottom when new output is received
  useEffect(() => {
    if (terminalRef.current) {
      terminalRef.current.scrollTop = terminalRef.current.scrollHeight;
    }
  }, [output]);
  
  // Show command info popup when a command is clicked
  const handleCommandClick = (command) => {
    setPopupCommand(command);
    setShowPopup(true);
  };
  
  return (
    <div className="terminal-panel">
      <div className="terminal-header">
        <div className="terminal-title">
          Bandit Level {currentLevel}
        </div>
        <div className="terminal-controls">
          {!connected ? (
            <button 
              className="connect-button" 
              onClick={connect}
              disabled={connecting}
            >
              {connecting ? 'Connecting...' : 'Connect'}
            </button>
          ) : (
            <button 
              className="disconnect-button" 
              onClick={disconnect}
            >
              Disconnect
            </button>
          )}
        </div>
      </div>
      
      <div className="terminal-body" ref={terminalRef}>
        <CommandOutput 
          output={output} 
          onCommandClick={handleCommandClick}
        />
      </div>
      
      <CommandInput 
        onSendCommand={sendCommand}
        disabled={!connected}
        history={commandHistory}
      />
      
      {showPopup && (
        <CommandInfoPopup
          command={popupCommand}
          onClose={() => setShowPopup(false)}
        />
      )}
      
      {levelCompleted && (
        <div className="level-completed-notification">
          <div className="notification-content">
            <h3>Level Completed!</h3>
            <p>You've found the password for the next level!</p>
            <button onClick={() => window.location.reload()}>
              Continue to Next Level
            </button>
          </div>
        </div>
      )}
    </div>
  );
};

export default Terminal;
```

#### CommandOutput.jsx

```jsx
import React from 'react';
import { highlightOutput } from '../utils/syntax-highlighter';
import { findCommands } from '../utils/command-analyzer';

const CommandOutput = ({ output, onCommandClick }) => {
  // Split output into lines
  const outputLines = output.split('\n');
  
  // Process each line to add syntax highlighting and make commands clickable
  const processedOutput = outputLines.map((line, index) => {
    // Check if the line contains a command prompt (e.g., bandit0@bandit:~$)
    if (line.match(/bandit\d+@bandit:.*\$/)) {
      // Extract command text after the prompt
      const promptEndIndex = line.indexOf('$') + 1;
      const prompt = line.substring(0, promptEndIndex);
      const commandText = line.substring(promptEndIndex).trim();
      
      if (commandText) {
        // Make command clickable
        return (
          <div key={index} className="command-line">
            <span className="prompt">{prompt} </span>
            <span 
              className="command clickable"
              onClick={() => onCommandClick(commandText)}
            >
              {commandText}
            </span>
          </div>
        );
      }
    }
    
    // Apply syntax highlighting to output
    return (
      <div
        key={index}
        className="output-line"
        dangerouslySetInnerHTML={{ __html: highlightOutput(line) }}
      />
    );
  });
  
  return <div className="terminal-output">{processedOutput}</div>;
};

export default CommandOutput;
```

#### CommandInput.jsx

```jsx
import React, { useState, useRef, useEffect } from 'react';

const CommandInput = ({ onSendCommand, disabled, history }) => {
  const [command, setCommand] = useState('');
  const [historyIndex, setHistoryIndex] = useState(-1);
  const inputRef = useRef(null);
  
  // Focus input when component mounts
  useEffect(() => {
    if (inputRef.current) {
      inputRef.current.focus();
    }
  }, []);
  
  // Handle key press events
  const handleKeyDown = (e) => {
    // Arrow up to navigate history
    if (e.key === 'ArrowUp' && historyIndex < history.length - 1) {
      e.preventDefault();
      const newIndex = historyIndex + 1;
      setHistoryIndex(newIndex);
      setCommand(history[newIndex]);
    }
    // Arrow down to navigate history
    else if (e.key === 'ArrowDown' && historyIndex > -1) {
      e.preventDefault();
      const newIndex = historyIndex - 1;
      setHistoryIndex(newIndex);
      setCommand(newIndex >= 0 ? history[newIndex] : '');
    }
    // Enter to submit command
    else if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSubmit();
    }
  };
  
  // Handle command submission
  const handleSubmit = () => {
    if (command.trim() && !disabled) {
      onSendCommand(command);
      setCommand('');
      setHistoryIndex(-1);
    }
  };
  
  return (
    <div className="command-input-container">
      <div className="command-prompt">bandit$</div>
      <input
        ref={inputRef}
        type="text"
        className="command-input"
        value={command}
        onChange={(e) => setCommand(e.target.value)}
        onKeyDown={handleKeyDown}
        disabled={disabled}
        placeholder={disabled ? "Connect to start..." : "Enter command..."}
      />
      <button
        className="send-button"
        onClick={handleSubmit}
        disabled={disabled || !command.trim()}
      >
        Send
      </button>
    </div>
  );
};

export default CommandInput;
```

#### CommandInfoPopup.jsx

```jsx
import React, { useEffect, useState } from 'react';
import { fetchCommandInfo } from '../services/chat';

const CommandInfoPopup = ({ command, onClose }) => {
  const [commandInfo, setCommandInfo] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  // Fetch command information when popup is shown
  useEffect(() => {
    // Parse command to get the base command (e.g., 'ls' from 'ls -la')
    const baseCommand = command.split(' ')[0];
    
    setLoading(true);
    fetchCommandInfo(baseCommand)
      .then(info => {
        setCommandInfo(info);
        setLoading(false);
      })
      .catch(err => {
        setError(`Failed to fetch information for '${baseCommand}'`);
        setLoading(false);
      });
  }, [command]);
  
  // Close popup when clicking outside
  const handleOutsideClick = (e) => {
    if (e.target.className === 'popup-overlay') {
      onClose();
    }
  };
  
  return (
    <div className="popup-overlay" onClick={handleOutsideClick}>
      <div className="command-info-popup">
        <div className="popup-header">
          <h3>{command}</h3>
          <button className="close-button" onClick={onClose}>×</button>
        </div>
        
        <div className="popup-content">
          {loading ? (
            <div className="loading-spinner">Loading...</div>
          ) : error ? (
            <div className="error-message">{error}</div>
          ) : (
            <>
              <div className="command-description">
                {commandInfo.description}
              </div>
              
              {commandInfo.syntax && (
                <div className="command-syntax">
                  <h4>Syntax</h4>
                  <code>{commandInfo.syntax}</code>
                </div>
              )}
              
              {commandInfo.options && commandInfo.options